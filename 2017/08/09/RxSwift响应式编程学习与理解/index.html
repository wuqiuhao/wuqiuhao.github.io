<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="iOS Swift Objective-C"><title>RxSwift响应式编程学习与理解 | Hale's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RxSwift响应式编程学习与理解</h1><a id="logo" href="/.">Hale's Blog</a><p class="description">stay hungry stay foolish</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RxSwift响应式编程学习与理解</h1><div class="post-meta">Aug 9, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><a data-disqus-identifier="2017/08/09/RxSwift响应式编程学习与理解/" href="/2017/08/09/RxSwift响应式编程学习与理解/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>最近公司在前端架构优化方案时提到了MVP和MVVM两种模式，其实这两种架构从接触移动端开发以来，一直有听到过，但是一直没有深入的去学习理解。借这次App代码重构的机会，我仔细的了解了MVP和MVVM两种架构。其中在接触MVVM时，提到了一种绑定（响应式）的概念，即Model和ViewModel之间双向绑定，View的变动，<code>自动</code>反映在 ViewModel，反之亦然。于是我就想利用业余时间好好学习一下RxSwift，理解这种响应式的方式是如何实现的。</p>
<h2 id="RxSwift的本质"><a href="#RxSwift的本质" class="headerlink" title="RxSwift的本质"></a>RxSwift的本质</h2><p>RxSwift官方文档中写到了所有<code>Observable</code>的实例都相当于Swift中的<code>Sequence</code>，并且和<code>Sequence</code>相比它还能异步的接受参数;<code>ObservableType.subscribe(_:)</code>就相当于Swift中的<code>Sequence.makeIterator()</code>,不同的是在RxSwift中不需要手动的调用<code>next()</code>方法，<code>Observable</code>就能自动的将事件发送给<code>Observer</code>。这就是RxSwift的本质，一切都建立在这个基础上。</p>
<h2 id="Observable和Observer"><a href="#Observable和Observer" class="headerlink" title="Observable和Observer"></a>Observable和Observer</h2><p>虽然已经很清楚的明白的RxSwift的本质所在，但是不搞清楚<code>Observable</code>和<code>Observer</code>这两个之间的关系，我始终对RxSwift一团污水。其实通过字面意思我们就可以知道<code>Observable</code>是可以被观察的意思，所以它是<code>被观察者</code>，那么<code>Observer</code>就是<code>观察者</code>，在RxSwift中<code>Observer</code>实现了<code>ObserverType</code>,这是一个<code>protocol</code>。<code>ObserverType</code>约定了一个方法<code>on(_ event: Event&lt;E&gt;)</code>用于封装被订阅者发送的事件回调。事件回调分为<code>next</code>、<code>error</code>和<code>completed</code>三种。同理，<code>Observable</code>也实现了一个协议<code>ObservableType</code>，<code>ObservableType</code>主要约定的方法为<code>subscribe&lt;O: ObserverType&gt;(_ observer: O)</code>,<code>subscribe</code>方法开放了自身被订阅的入口，观察者可以通过这个方法订阅被观察对象。</p>
<h2 id="Let‘s-Try"><a href="#Let‘s-Try" class="headerlink" title="Let‘s Try"></a>Let‘s Try</h2><p>这里我省略了RxSwift的一些语法教程，因为本文主要是想要和大家分享我对RxSwift响应式实现的理解。如果有不理解的地方可以直接到github上下载<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift-master</a>,里面的<code>Rx.playground</code>是很好的一份RxSwift语法教程。进入正题，以下是一段我用RxSwift写的伪代码，模拟了用户发起网络请求，并将网络请求的结果异步返回给观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let observable = Observable.create(&#123; (observer) -&gt; Disposable in</div><div class="line">       let request = MyRequestAPI.get(url, ( (result, error) -&gt; &#123;</div><div class="line">           if let err = error &#123;</div><div class="line">               observer.onError(err)</div><div class="line">           &#125;</div><div class="line">           else if let response = result &#123;</div><div class="line">               observer.onNext(response)</div><div class="line">               observer.onComplete()</div><div class="line">           &#125;</div><div class="line">       &#125;)</div><div class="line">       return AnonymousDisposable &#123;</div><div class="line">           request.cancel()</div><div class="line">       &#125;</div><div class="line">   &#125;)</div><div class="line">   </div><div class="line">observable.subscribe(onNext: &#123; (response) in</div><div class="line">       // receive data do some thing</div><div class="line">   &#125;, onError: &#123; (err) in</div><div class="line">       // error do some thing</div><div class="line">   &#125;, onCompleted: &#123;</div><div class="line">       // complete request do some thing</div><div class="line">   &#125;, onDisposed: &#123;</div><div class="line">       // deinit</div><div class="line">   &#125;)</div></pre></td></tr></table></figure></p>
<p>在上面这段代码中，我通过<code>create</code>方法创建了一个<code>observable</code>实例，将MyRequestAPI的返回职能移交给了一个<code>observer</code>对象，当网络请求异常时，我会调用<code>observer.onError()</code>，这意味着，只要监听了这个<code>observable</code>对象，就会接收到错误的消息。事实上在第二段代码中我正是这么做的，通过对<code>observable</code>的<code>subscribe</code>，分别对网络请求的成功返回、异常、结束、释放等状态进行了监听。从而能够在相应的事件到来之际，进行相应的操作。</p>
<h2 id="最初的疑问"><a href="#最初的疑问" class="headerlink" title="最初的疑问"></a>最初的疑问</h2><p>现在我们已经对RxSwift的思维有所了解。但心中可能还是有一个疑问，RxSwift是如何实现响应式这种方式的？通过阅读<code>Observable.create</code>的源码，我从中找到了答案。在Rx内部有一个集合Observers，在我们执行监听方法<code>subscribe</code>的时候，以上面代码的<code>onNext</code>为例，此时在其内部会执行<code>_observers.insert(observer.on)</code>这样一段代码，就是将这种状态的监听加入到集合中，待我们调用<code>observer.onNext(response)</code>方法的时候，它会去遍历<code>_observers</code>，如果集合中存在相同的状态类型，则执行对应状态的<code>eventHander</code>闭包。</p>
<h2 id="冰山一角"><a href="#冰山一角" class="headerlink" title="冰山一角"></a>冰山一角</h2><p>如果要使用RxSwift实现一个MVVM架构的应用，那上面提到的应用知识只是冰山一角，毕竟RxSwift是一个很庞大的项目，他还有一个名字类似的仓库叫RxCocoa，基本上来说，RxCocoa给所有的 Cocoa 类建立了扩展方法，从而可以让UI视图建立诸如<code>rx.text</code>之类的东西。这样我们就不需要像上面一样手动创建Observable对象，可以少写一点subscribeNext方法，从而在多个不同的视图点中将值和观察值之间建立关联。类似下面的代码这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let textField = UITextField()</div><div class="line">let delegate = TextFieldDelegate()</div><div class="line">textField.delegate = delegate</div><div class="line">var rxDidChange = false</div><div class="line">		</div><div class="line">_ = textField.rx.text</div><div class="line">	.skip(1) // Initial value</div><div class="line">	.subscribe(onNext: &#123; _ in</div><div class="line">	rxDidChange = true</div><div class="line">	&#125;, onCompleted: &#123;</div><div class="line">	completed = true</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我对RxSwift主要思想的理解，旨在帮助想要入坑RxSwift的朋友更好地入门。毕竟RxSwift是一个比较庞大的体系，通过这次学习还有很多RxSwift的知识和语法没有了解，我也会在这个基础上，继续学习。</p>
</div><div class="tags"><a href="/tags/RxSwift/">RxSwift</a></div><div class="post-nav"><a href="/2017/09/01/Concurrency Programing in Swift/" class="pre">Concurrency Programing in Swift</a><a href="/2017/07/17/WCDB理解/" class="next">WCDB理解</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'Hale';
var disqus_identifier = '2017/08/09/RxSwift响应式编程学习与理解/';
var disqus_title = 'RxSwift响应式编程学习与理解';
var disqus_url = 'http://wuqiuhao.github.io/2017/08/09/RxSwift响应式编程学习与理解/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//Hale.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://wuqiuhao.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/GeneratorType/" style="font-size: 15px;">GeneratorType</a> <a href="/tags/SequenceType/" style="font-size: 15px;">SequenceType</a> <a href="/tags/UILabel/" style="font-size: 15px;">UILabel</a> <a href="/tags/RxSwift/" style="font-size: 15px;">RxSwift</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/自动打包/" style="font-size: 15px;">自动打包</a> <a href="/tags/Custom-Transition/" style="font-size: 15px;">Custom Transition</a> <a href="/tags/AVPlayerViewController/" style="font-size: 15px;">AVPlayerViewController</a> <a href="/tags/Concurrency-Operations-GCD/" style="font-size: 15px;">Concurrency Operations GCD</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/Concurrency Programing in Swift/">Concurrency Programing in Swift</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/09/RxSwift响应式编程学习与理解/">RxSwift响应式编程学习与理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/WCDB理解/">WCDB理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/17/iOS自定义模态视图转场/">iOS自定义模态视图转场</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/08/fastlane gym实现ipa自动打包脚本/">使用fastlane gym实现ipa自动打包脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/02/Swift中的生成器和序列/">Swift中的生成器和序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/iOS视频、音频播放/">iOS视频、音频播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/30/UILabel垂直方向布局调整——实现居上居下效果/">UILabel垂直方向布局调整——实现居上居下效果</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//Hale.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Hale's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.1.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.1.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.1.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.1.0"></script></div></body></html>