<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hale&#39;s Blog</title>
  <subtitle>stay hungry stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuqiuhao.github.io/"/>
  <updated>2017-09-11T13:04:38.000Z</updated>
  <id>http://wuqiuhao.github.io/</id>
  
  <author>
    <name>Hale</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Concurrency Programing in Swift</title>
    <link href="http://wuqiuhao.github.io/2017/09/01/Concurrency%20Programing%20in%20Swift/"/>
    <id>http://wuqiuhao.github.io/2017/09/01/Concurrency Programing in Swift/</id>
    <published>2017-09-01T14:03:35.000Z</published>
    <updated>2017-09-11T13:04:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讨论和介绍Swift的并发编程，现在iOS中有两套比较先进的并发编程方案可以供我们使用，一个是<code>GCD</code>，另一个是<code>操作队列（Operation Queues）</code>。GCD是一套基于C的底层API，而操作队列是在GCD基础上的面相对象抽象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能。</p>
<hr>
<h1 id="Operations-amp-Operation-Queues"><a href="#Operations-amp-Operation-Queues" class="headerlink" title="Operations &amp; Operation Queues"></a>Operations &amp; Operation Queues</h1><p><code>Operations（操作）</code>以一种面向对象的方式来封装需要执行的异步任务，是一套较为高级的API。Operations在Swift中主要有<code>Operation</code>和<code>BlockOperation</code>两个类，他们可以各自单独使用，也可以被添加到<code>Operation Queue（操作队列）</code>中执行任务。</p>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><p>Operation是操作的一个基类，我们一般可以通过继承的方式来实现一些自定义的操作类，例如通过自定义操作类我们能够更改操作的执行方式或者打印作业执行过程中的状态变化。如果我们直接继承Operation实现的操作类是同步（Sync）执行的，我们也可以通过手动管理state来实现操作类的异步（Async）执行。下面我们将自定义实现一个AsyncOperation：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">class AsyncOperation: Operation &#123;</div><div class="line">  enum State: String &#123;</div><div class="line">    case Ready, Executing, Finished</div><div class="line">    </div><div class="line">    fileprivate var keyPath: String &#123;</div><div class="line">      return &quot;is&quot; + rawValue</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  var state = State.Ready &#123;</div><div class="line">    willSet &#123;</div><div class="line">      willChangeValue(forKey: newValue.keyPath)</div><div class="line">      willChangeValue(forKey: state.keyPath)</div><div class="line">    &#125;</div><div class="line">    didSet &#123;</div><div class="line">      didChangeValue(forKey: oldValue.keyPath)</div><div class="line">      didChangeValue(forKey: state.keyPath)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension AsyncOperation &#123;</div><div class="line">  // NSOperation Overrides</div><div class="line">  override var isReady: Bool &#123;</div><div class="line">    return super.isReady &amp;&amp; state == .Ready</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  override var isExecuting: Bool &#123;</div><div class="line">    return state == .Executing</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  override var isFinished: Bool &#123;</div><div class="line">    return state == .Finished</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  override var isAsynchronous: Bool &#123;</div><div class="line">    return true</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  override func start() &#123;</div><div class="line">    if isCancelled &#123;</div><div class="line">      state = .Finished</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">    main()</div><div class="line">    state = .Executing</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  override func cancel() &#123;</div><div class="line">    state = .Finished</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了AsyncOperation之后，我们可以通过以下步骤调用：</p>
<blockquote>
<p>1.继承AsyncOperation<br>2.重写main方法，在main方法中执行Async操作<br>3.在Async的callback方法中将state置为<code>.Finished</code></p>
</blockquote>
<p>调用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyLoginOperation: AsyncOperation &#123;</div><div class="line">  override func main() &#123;</div><div class="line">    RequestAPI.login(params, callback: &#123;</div><div class="line">        self.state = .Finished</div><div class="line">        // TODO: login success</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let op = MyLoginOperation()</div><div class="line">OperationQueue().addOperation(op)</div></pre></td></tr></table></figure></p>
<h3 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h3><p>BlockOperation,继承自Operation，可以并发的执行一个或多个block，只有当所有的block都执行完毕，整个操作才算执行完毕。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let blockOperation = BlockOperation &#123;</div><div class="line">    sleep(2)</div><div class="line">    print(&quot;🍎&quot;)</div><div class="line">&#125;</div><div class="line">blockOperation.addExecutionBlock &#123;</div><div class="line">    print(&quot;🍏&quot;)</div><div class="line">&#125;</div><div class="line">blockOperation.addExecutionBlock &#123;</div><div class="line">    print(&quot;🍐&quot;)</div><div class="line">&#125;</div><div class="line">blockOperation.addExecutionBlock &#123;</div><div class="line">    print(&quot;🍇&quot;)</div><div class="line">&#125;</div><div class="line">blockOperation.completionBlock = &#123;</div><div class="line">    print(&quot;all works cmplete!&quot;)</div><div class="line">&#125;</div><div class="line">blockOperation.start()</div></pre></td></tr></table></figure></p>
<p>示例输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">🍇</div><div class="line">🍏</div><div class="line">🍐</div><div class="line">🍎</div><div class="line">all works cmplete!</div></pre></td></tr></table></figure></p>
<h2 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>上面我们提到了我们可以调用operation自身的start方法出发作业执行，但是在日常开发中，我们往往采用将operation添加到一个指定的queue中来执行作业。操作队列是<code>OperationQueue</code>的一个实例，任务一旦被添加到操作队列中不久便会自动执行操作，所以如果需要设置操作或队列的一些属性，需要在其被添加到队列之前设置，在添加到队列之后的设置将不会生效。操作队列默认是一个并行队列，我们可以通过<code>maxConcurrentOperationCount</code>这个属性设置队列的并发数，当并发数为1的时候，操作队列就是一个串行队列。操作队列默认是（Async）异步执行的，我们也可以通过调用<code>waitUntilAllOperationsAreFinished()</code>方法或将<code>addOperations(_ ops: [Operation], waitUntilFinished wait: Bool)</code>方法的<code>waitUntilFinished</code>属性设置为true,使其成为同步（Sync）同步队列。下面通过示例代码来详细讲解操作队列的使用。</p>
<p>1.首先我们创建了4个operation和一个操作队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let op1 = BlockOperation &#123;</div><div class="line">    sleep(2)</div><div class="line">    print(&quot;🍎&quot;)</div><div class="line">&#125;</div><div class="line">let op2 = BlockOperation &#123;</div><div class="line">    print(&quot;🍏&quot;)</div><div class="line">&#125;</div><div class="line">let op3 = BlockOperation &#123;</div><div class="line">    print(&quot;🍐&quot;)</div><div class="line">&#125;</div><div class="line">let op4 = BlockOperation &#123;</div><div class="line">    print(&quot;🍇&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let queue = OperationQueue()</div></pre></td></tr></table></figure></p>
<p>2.然后我们设置了队列的并发数为4，并将4个操作对象添加到了操作队列中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue.maxConcurrentOperationCount = 4</div><div class="line">queue.addOperations([op1,op2,op3,op4], waitUntilFinished: true)</div></pre></td></tr></table></figure></p>
<p>示例输出1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">🍏</div><div class="line">🍐</div><div class="line">🍇</div><div class="line">🍎</div></pre></td></tr></table></figure></p>
<p>这个结果我们并不感到意外，由于是并发队列，并且op1的作业中含有延时操作，所以前三个的输出顺序并不一定，但是第四个输出的一定是🍎。如果我们把上面第2步的代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue.maxConcurrentOperationCount = 4</div><div class="line">queue.addOperations([op1,op2,op3,op4], waitUntilFinished: false)</div></pre></td></tr></table></figure></p>
<p>示例输出2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">🍏</div><div class="line">🍐</div><div class="line">🍇</div></pre></td></tr></table></figure></p>
<p>此时队列并发异步执行操作，由于op1的延时处理，op1的执行将被直接返回，所以最终输出结果中并没有op1的输出。如果将上面的代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue.maxConcurrentOperationCount = 1</div><div class="line">queue.addOperations([op1,op2,op3,op4], waitUntilFinished: true)</div></pre></td></tr></table></figure></p>
<p>示例输出3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">🍎</div><div class="line">🍏</div><div class="line">🍐</div><div class="line">🍇</div></pre></td></tr></table></figure></p>
<p>此时操作队列是一个串行队列，所以程序执行2s后依次执行队列中的操作，按FIFO的顺序输出了结果。如果我们将上面的代码修改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">queue.maxConcurrentOperationCount = 1</div><div class="line">queue.addOperations([op1,op2,op3,op4], waitUntilFinished: false)</div></pre></td></tr></table></figure></p>
<p>示例输出4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">是的，代码执行后控制台将没有任何输出。由于我们设置队列的并发数为1，所以当前只有一个线程用于任务调度，同时我们设置了`waitUntilFinished`为false，说明这是一个异步执行的队列，所以当执行op1延时函数时，唯一的线程直接返回了，所以后续的操作都不会被执行。</div><div class="line">### Dependencies</div><div class="line">如果在开发过程中我们想要操作按我们指定的顺序来执行，operation为我们提供了一种十分便捷的方式，operation支持互相设置依赖，如op1依赖于op2，op2依赖于op3，那么操作的执行顺秀就会是op3-&gt;op2-&gt;op1。示例代码如下:</div></pre></td></tr></table></figure></p>
<p>let op1 = BlockOperation {<br>    print(“🍎”)<br>}<br>let op2 = BlockOperation {<br>    print(“🍏”)<br>}<br>let op3 = BlockOperation {<br>    print(“🍐”)<br>}</p>
<p>let queue = OperationQueue()<br>queue.maxConcurrentOperationCount = 3<br>op1.addDependency(op2)<br>op2.addDependency(op3)<br>queue.addOperations([op1,op2,op3], waitUntilFinished: false)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">示例输出：</div></pre></td></tr></table></figure></p>
<p>🍐<br>🍏<br>🍎<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### Suspending and Resuming Queues</div><div class="line">另外操作队列可以非常方便的进行挂起和恢复操作，我们可以通过队列的`isSuspended`属性设置队列的挂起和恢复，但是队列的挂起，不会影响已经被添加到队列中的操作，只有后续被添加到队列的操作会收到影响。我们直接看示例代码：</div></pre></td></tr></table></figure></p>
<p>let op1 = BlockOperation {<br>    print(“🍎”)<br>}<br>let op2 = BlockOperation {<br>    print(“🍏”)<br>}<br>let op3 = BlockOperation {<br>    print(“🍐”)<br>}</p>
<p>let queue = OperationQueue()<br>queue.maxConcurrentOperationCount = 3<br>queue.addOperations([op1,op2], waitUntilFinished: false)</p>
<p>queue.isSuspended = true<br>queue.addOperation(op3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">示例输出：</div></pre></td></tr></table></figure></p>
<p>🍎<br>🍏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### Practice</div><div class="line">在实际开发过程中，我们常常将一些耗时操作放到子线程，待操作完成后，我们切回main线程，进行一些UI相关的操作。其实这一过程可以用操作队列很方便的实现。</div></pre></td></tr></table></figure></p>
<p>OperationQueue().addOperation {<br>            // TODO: some time consuming operations<br>            OperationQueue.main.addOperation {<br>                // TODO: some UI operations<br>            }<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">## Operations小结</div><div class="line">通过上面的介绍和使用，我们发现操作队列还是比较灵活和方便的，可以很方便的添加依赖。虽然它是高层级的API，相对于底层API来说可控制的权限会少一些，性能上可能稍有偏差，但在一定的场景下，还是很值得推荐的。</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># GCD</div><div class="line">GCD是Apple提供的另一套基于C的高性能底层API，利用它我们可以进行高性能的并发编程。Swift3之前它还保持了C语言的调用分格，Swift3之后Apple对其进行了重新封装，新的API更符合面向对象思维，所有的任务都会被包装到一个函数或者闭包中，可读性更强，也更便于使用了。</div><div class="line">## Dispatch queues</div><div class="line">`Dispatch queues（调度队列）`可以很方便的创建并执行（Async）异步和（Sync）同步任务。例如你可以将一些耗时任务添加到一个函数或者block，然后将其添加到调度队列中执行。GCD默认实现了一些队列，我们也可以通过GCD提供的方法创建自定义队列。</div><div class="line">### 串行队列</div><div class="line">在GCD中如不进行特殊处理默认创建的都是串行队列。用代码说话，我们可以通过如下方式创建串行队列：</div></pre></td></tr></table></figure></p>
<p>let queue1 = DispatchQueue(label: “SerialQueue1”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">向队列中添加作业可以通过如下方式，同时你还可以控制队列中的任务将以（Async）异步或（Sync）同步的方式执行。</div></pre></td></tr></table></figure></p>
<p>queue1.sync {<br>    print(“🍊 (Thread.current)”)<br>}</p>
<p>queue1.async {<br>    sleep(2)<br>    print(“🍎 (Thread.current)”)<br>}</p>
<p>queue1.sync {<br>    print(“🍐 (Thread.current)”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">示例输出：</div></pre></td></tr></table></figure></p>
<p>🍊 <nsthread: 0x100a061e0="">{number = 1, name = main}<br>🍎 <nsthread: 0x100a0b410="">{number = 2, name = (null)}<br>🍐 <nsthread: 0x100a061e0="">{number = 1, name = main}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">调度队列中的main主队列就是一个串行队列，它只能存在于主线程之中。所以我们不能够往主队列中添加（Sync）同步操作，因为同步操作会堵塞主线程。</div><div class="line">### 并发队列</div><div class="line">系统默认实现了一个全局的并发队列，如果没有什么特殊需求一般我们直接可以拿来使用,示例如下：</div></pre></td></tr></table></figure></nsthread:></nsthread:></nsthread:></p>
<p>DispatchQueue.global().async {<br>    // TODO: some time consuming operations<br>    DispatchQueue.main.async {<br>        // TODO: some UI operations<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是我们日常开发中常用的一种方式，我们一般将比较耗时的操作放入全局并发队列，待耗时任务完成切换回主队列进行UI相关的操作。如果我们有特殊需求，同样可以自定义并发队列：</div></pre></td></tr></table></figure></p>
<p>let queue = DispatchQueue(label: “concurrencyQueue”, attributes: .concurrent)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### Dispatch Group</div><div class="line">如果在实际开发中我们希望多个网络请求都返回了在执行相应的操作，我们可以使用Dispatch Group很方便的实现：</div></pre></td></tr></table></figure></p>
<p>let group = DispatchGroup()<br>let queue = DispatchQueue(label: “groupQueue”)</p>
<p>queue.async(group: group) {<br>    print(“🍏”)<br>}</p>
<p>queue.async(group: group) {<br>    print(“🍎”)<br>}</p>
<p>group.notify(queue: queue) {<br>    print(“all tasks complete”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">示例输出：</div></pre></td></tr></table></figure></p>
<p>🍏<br>🍎<br>all tasks complete<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 延时操作</div><div class="line">在开发中我们经常会遇到一些延时操作，Dispatch queue提供了一套非常简单的方法。示例如下：</div></pre></td></tr></table></figure></p>
<p>let queue = DispatchQueue(label: “queuename”)<br>queue.asyncAfter(deadline: .now() + 2) {<br>    // TODO: some task<br>}<br>```</p>
<h2 id="GCD小结"><a href="#GCD小结" class="headerlink" title="GCD小结"></a>GCD小结</h2><p>本文列举了GCD中在并发编程中常见的一些操作，还有一部分关于<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="external">Dispatch Sources</a>没有展开，希望感兴趣的朋友可以自行研究。</p>
<hr>
<h1 id="操作队列（Operation-Queues）还是GCD？"><a href="#操作队列（Operation-Queues）还是GCD？" class="headerlink" title="操作队列（Operation Queues）还是GCD？"></a>操作队列（Operation Queues）还是GCD？</h1><p>我认为在并发编程中，在相同的场景下，如果实现难度相当，我们首选GCD，毕竟它是比较底层的实现，性能也会出色些。但是如果有的场景操作队列实现起来方便得多，我们完全可以直接使用操作队列实现。另外，选择操作队列还是GCD也因人而异，不管是哪一种只要使用起来得心应手，都是可以的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讨论和介绍Swift的并发编程，现在iOS中有两套比较先进的并发编程方案可以供我们使用，一个是&lt;code&gt;GCD&lt;/code&gt;，另一个是&lt;code&gt;操作队列（Operation Queues）&lt;/code&gt;。GCD是一套基于C的底层API，而操作队列是在GCD基础上
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="Concurrency Operations GCD" scheme="http://wuqiuhao.github.io/tags/Concurrency-Operations-GCD/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift响应式编程学习与理解</title>
    <link href="http://wuqiuhao.github.io/2017/08/09/RxSwift%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://wuqiuhao.github.io/2017/08/09/RxSwift响应式编程学习与理解/</id>
    <published>2017-08-09T14:03:35.000Z</published>
    <updated>2017-08-08T16:46:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司在前端架构优化方案时提到了MVP和MVVM两种模式，其实这两种架构从接触移动端开发以来，一直有听到过，但是一直没有深入的去学习理解。借这次App代码重构的机会，我仔细的了解了MVP和MVVM两种架构。其中在接触MVVM时，提到了一种绑定（响应式）的概念，即Model和ViewModel之间双向绑定，View的变动，<code>自动</code>反映在 ViewModel，反之亦然。于是我就想利用业余时间好好学习一下RxSwift，理解这种响应式的方式是如何实现的。</p>
<h2 id="RxSwift的本质"><a href="#RxSwift的本质" class="headerlink" title="RxSwift的本质"></a>RxSwift的本质</h2><p>RxSwift官方文档中写到了所有<code>Observable</code>的实例都相当于Swift中的<code>Sequence</code>，并且和<code>Sequence</code>相比它还能异步的接受参数;<code>ObservableType.subscribe(_:)</code>就相当于Swift中的<code>Sequence.makeIterator()</code>,不同的是在RxSwift中不需要手动的调用<code>next()</code>方法，<code>Observable</code>就能自动的将事件发送给<code>Observer</code>。这就是RxSwift的本质，一切都建立在这个基础上。</p>
<h2 id="Observable和Observer"><a href="#Observable和Observer" class="headerlink" title="Observable和Observer"></a>Observable和Observer</h2><p>虽然已经很清楚的明白的RxSwift的本质所在，但是不搞清楚<code>Observable</code>和<code>Observer</code>这两个之间的关系，我始终对RxSwift一团污水。其实通过字面意思我们就可以知道<code>Observable</code>是可以被观察的意思，所以它是<code>被观察者</code>，那么<code>Observer</code>就是<code>观察者</code>，在RxSwift中<code>Observer</code>实现了<code>ObserverType</code>,这是一个<code>protocol</code>。<code>ObserverType</code>约定了一个方法<code>on(_ event: Event&lt;E&gt;)</code>用于封装被订阅者发送的事件回调。事件回调分为<code>next</code>、<code>error</code>和<code>completed</code>三种。同理，<code>Observable</code>也实现了一个协议<code>ObservableType</code>，<code>ObservableType</code>主要约定的方法为<code>subscribe&lt;O: ObserverType&gt;(_ observer: O)</code>,<code>subscribe</code>方法开放了自身被订阅的入口，观察者可以通过这个方法订阅被观察对象。</p>
<h2 id="Let‘s-Try"><a href="#Let‘s-Try" class="headerlink" title="Let‘s Try"></a>Let‘s Try</h2><p>这里我省略了RxSwift的一些语法教程，因为本文主要是想要和大家分享我对RxSwift响应式实现的理解。如果有不理解的地方可以直接到github上下载<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift-master</a>,里面的<code>Rx.playground</code>是很好的一份RxSwift语法教程。进入正题，以下是一段我用RxSwift写的伪代码，模拟了用户发起网络请求，并将网络请求的结果异步返回给观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let observable = Observable.create(&#123; (observer) -&gt; Disposable in</div><div class="line">       let request = MyRequestAPI.get(url, ( (result, error) -&gt; &#123;</div><div class="line">           if let err = error &#123;</div><div class="line">               observer.onError(err)</div><div class="line">           &#125;</div><div class="line">           else if let response = result &#123;</div><div class="line">               observer.onNext(response)</div><div class="line">               observer.onComplete()</div><div class="line">           &#125;</div><div class="line">       &#125;)</div><div class="line">       return AnonymousDisposable &#123;</div><div class="line">           request.cancel()</div><div class="line">       &#125;</div><div class="line">   &#125;)</div><div class="line">   </div><div class="line">observable.subscribe(onNext: &#123; (response) in</div><div class="line">       // receive data do some thing</div><div class="line">   &#125;, onError: &#123; (err) in</div><div class="line">       // error do some thing</div><div class="line">   &#125;, onCompleted: &#123;</div><div class="line">       // complete request do some thing</div><div class="line">   &#125;, onDisposed: &#123;</div><div class="line">       // deinit</div><div class="line">   &#125;)</div></pre></td></tr></table></figure></p>
<p>在上面这段代码中，我通过<code>create</code>方法创建了一个<code>observable</code>实例，将MyRequestAPI的返回职能移交给了一个<code>observer</code>对象，当网络请求异常时，我会调用<code>observer.onError()</code>，这意味着，只要监听了这个<code>observable</code>对象，就会接收到错误的消息。事实上在第二段代码中我正是这么做的，通过对<code>observable</code>的<code>subscribe</code>，分别对网络请求的成功返回、异常、结束、释放等状态进行了监听。从而能够在相应的事件到来之际，进行相应的操作。</p>
<h2 id="最初的疑问"><a href="#最初的疑问" class="headerlink" title="最初的疑问"></a>最初的疑问</h2><p>现在我们已经对RxSwift的思维有所了解。但心中可能还是有一个疑问，RxSwift是如何实现响应式这种方式的？通过阅读<code>Observable.create</code>的源码，我从中找到了答案。在Rx内部有一个集合Observers，在我们执行监听方法<code>subscribe</code>的时候，以上面代码的<code>onNext</code>为例，此时在其内部会执行<code>_observers.insert(observer.on)</code>这样一段代码，就是将这种状态的监听加入到集合中，待我们调用<code>observer.onNext(response)</code>方法的时候，它会去遍历<code>_observers</code>，如果集合中存在相同的状态类型，则执行对应状态的<code>eventHander</code>闭包。</p>
<h2 id="冰山一角"><a href="#冰山一角" class="headerlink" title="冰山一角"></a>冰山一角</h2><p>如果要使用RxSwift实现一个MVVM架构的应用，那上面提到的应用知识只是冰山一角，毕竟RxSwift是一个很庞大的项目，他还有一个名字类似的仓库叫RxCocoa，基本上来说，RxCocoa给所有的 Cocoa 类建立了扩展方法，从而可以让UI视图建立诸如<code>rx.text</code>之类的东西。这样我们就不需要像上面一样手动创建Observable对象，可以少写一点subscribeNext方法，从而在多个不同的视图点中将值和观察值之间建立关联。类似下面的代码这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let textField = UITextField()</div><div class="line">let delegate = TextFieldDelegate()</div><div class="line">textField.delegate = delegate</div><div class="line">var rxDidChange = false</div><div class="line">		</div><div class="line">_ = textField.rx.text</div><div class="line">	.skip(1) // Initial value</div><div class="line">	.subscribe(onNext: &#123; _ in</div><div class="line">	rxDidChange = true</div><div class="line">	&#125;, onCompleted: &#123;</div><div class="line">	completed = true</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我对RxSwift主要思想的理解，旨在帮助想要入坑RxSwift的朋友更好地入门。毕竟RxSwift是一个比较庞大的体系，通过这次学习还有很多RxSwift的知识和语法没有了解，我也会在这个基础上，继续学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司在前端架构优化方案时提到了MVP和MVVM两种模式，其实这两种架构从接触移动端开发以来，一直有听到过，但是一直没有深入的去学习理解。借这次App代码重构的机会，我仔细的了解了MVP和MVVM两种架构。其中在接触MVVM时，提到了一种绑定（响应式）的概念，即Model
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="RxSwift" scheme="http://wuqiuhao.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>WCDB理解</title>
    <link href="http://wuqiuhao.github.io/2017/07/17/WCDB%E7%90%86%E8%A7%A3/"/>
    <id>http://wuqiuhao.github.io/2017/07/17/WCDB理解/</id>
    <published>2017-07-17T02:47:08.000Z</published>
    <updated>2017-07-17T15:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WCDB（WeChat DataBase）是微信官方的移动端数据库组件，它基于SQLCipher，是一个关系型数据库，支持iOS, macOS和Android。WCDB提供了三个基础类进行数据库操作：WCTDatabase、WCTTable、WCTTransaction。它们的接口都是线程安全的。WCDB几乎涵盖了常用的数据库操作，同时还开放了核心层接口，方便用户扩展一些未封装的复杂SQL操作。安全方面它继承了SQLCipher的加密方式，内建了Repair Kit用于修复损坏的数据库,通过内建宏的方式实现了<code>ORM（Object Relational Mapping)</code>，方便地实现了对象属性到数据表字段的映射,通过一种名为<code>WINQ</code>的规则对SQL进行了抽象，避免了冗长的SQL胶水代码，也防止了SQL注入。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>WCDB使用内置的宏来连接类、属性与表、字段。共有三类宏，分别对应数据库的字段、索引和约束。所有宏都定义在WCTCodingMacro.h中。WCDB的ORM会自动识别property的类型，并映射到适合的数据库类型。其与Objective-C类型对应关系为：</p>
<ul>
<li>整型<ul>
<li>NSDate（保存其时间戳）</li>
</ul>
</li>
<li>浮点数<ul>
<li>NSNumber</li>
</ul>
</li>
<li>字符串<ul>
<li>NSString、NSMutableString</li>
</ul>
</li>
<li>二进制<ul>
<li>NSData、NSMutableData</li>
<li>NSArray、NSMutableArray</li>
<li>NSDictionary、NSMutableDictionary</li>
<li>NSSet、NSMutableSet</li>
<li>NSValue</li>
<li>NSURL</li>
</ul>
</li>
</ul>
<p>关于ORM官方github文档给出了详细的中英文教程包括字段宏、索引宏、约束宏等在此不一一列举。</p>
<h2 id="WINQ"><a href="#WINQ" class="headerlink" title="WINQ"></a>WINQ</h2><p>WINQ避免了冗长复杂的SQL拼接操作，对SQL语句进行了抽象。抽象的思路还是从SQL语法规则出发，SQL的语法规则实则上是一种链式操作，可以理解为一些固定的keyword、object和expr的集合。所以WINQ的实现思路是将固定的keyword，封装为函数名，作为连接；将可以展开的token，封装为类，并在类内实现其不同的组合。这句话可能说的有点绕，通过下面的代码块可能比较好理解些。在下面的代码块中，把<code>SELECT</code>定义成了一个类<code>StatementSelect</code>,这个类有三个函数，函数名我们并不陌生，正是<code>where</code>、<code>limit</code>、<code>having</code>三个SQL关键字，同时函数的返回也是一个StatementSelect对象，这样我们就能实现一种链式操作。实现了上面提到的<code>连接</code>。另外我们可以发现三个函数还有一个共同点，它们的参数都是Expr类型，因为在实际的SQL语法规则中where、limit、having等操作都是接受表达式的，所以这里StatementSelect的类方法都是表达式。然后在Expr内部可以实现表达式的各种组合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class StatementSelect : public Statement &#123;</div><div class="line">public:</div><div class="line">    //...</div><div class="line">    StatementSelect &amp;where(const Expr &amp;where);</div><div class="line">    StatementSelect &amp;limit(const Expr &amp;limit);</div><div class="line">    StatementSelect &amp;having(const Expr &amp;having);</div><div class="line">    //...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Expr : public Describable &#123;</div><div class="line">public:</div><div class="line">    Expr(const Column &amp;column);</div><div class="line">    template &lt;typename T&gt;</div><div class="line">    Expr(const T &amp;value,</div><div class="line">         typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value ||</div><div class="line">                                 std::is_enum&lt;T&gt;::value&gt;::type * = nullptr)</div><div class="line">        : Describable(literalValue(value))</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">    Expr(const std::string &amp;value);</div><div class="line"></div><div class="line">    Expr operator||(const Expr &amp;operand) const;</div><div class="line">    Expr operator&amp;&amp;(const Expr &amp;operand) const;</div><div class="line">    Expr operator!=(const Expr &amp;operand) const;</div><div class="line"></div><div class="line">    Expr between(const Expr &amp;left, const Expr &amp;right) const;</div><div class="line">    Expr notBetween(const Expr &amp;left, const Expr &amp;right) const;</div><div class="line"></div><div class="line">    Expr isNull() const;</div><div class="line">    Expr isNotNull() const;</div><div class="line">    </div><div class="line">    //...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>基于这个抽象方式，就可以对复杂查询中的条件语句进行重写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Column content(&quot;content&quot;);</div><div class="line">Column createTime(&quot;createTime&quot;);</div><div class="line">Column modifiedTime(&quot;modifiedTime&quot;);</div><div class="line">Column type(&quot;type&quot;);</div><div class="line">StatementSelect select;</div><div class="line">//...</div><div class="line">//WHERE content IS NOT NULL </div><div class="line">//      AND createTime!=modifiedTime </div><div class="line">//      OR type NOT BETWEEN 0 AND 2</div><div class="line">select.where(Expr(content).isNotNull()</div><div class="line">            &amp;&amp;Expr(createTime)!=Expr(modifiedTime)</div><div class="line">            ||Expr(type).notBetween(0, 2));</div><div class="line">//...</div></pre></td></tr></table></figure></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>WCTDatabase表示一个数据库，可以进行所有数据库操作，包括增删查改、表操作、事务、文件操作、损坏修复等。对于同一个路径的数据库，不同的WCTDatabase、WCTTable、WCTTransaction对象共享同一个WCDB核心。因此，你可以在代码的不同位置、不同线程任意创建不同的基础类对象，WCDB会自动管理它们的共享数据和线程并发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,</div><div class="line"> NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;test.db&quot;];</div><div class="line">_database = [[WCTDatabase alloc] initWithPath: path];</div><div class="line">[_database close:^&#123;</div><div class="line">	[_database removeFilesWithError:nil];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![_database isTableExists:@&quot;student&quot;]) &#123;</div><div class="line">	[_database createTableAndIndexesOfName:@&quot;student&quot; withClass:Student.class];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student *student = [[Student alloc] init];</div><div class="line">student.studentID = studentID;</div><div class="line">student.name = name;</div><div class="line">[_database insertObject:student into:@&quot;student&quot;];</div></pre></td></tr></table></figure>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">return [_database getOneObjectOfClass:Student.class </div><div class="line">fromTable:@&quot;student&quot; where:Student.studentID == studentID];</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我通读了WCDB的iOS官方文档和API做的一些总结，其中有一些自己的理解，同时也概括了WCDB的核心理念和使用方法。另外还有一些关于数据库修复、事务、约束的操作，没有详细列举。可以直接访问其github里面的中英文教程讲的非常详细。另外截止到2016年12月微信全球共计8.89亿月活用户，而新兴的公众号平台拥有1000万个，WCDB作为支撑这么一个平台的移动端数据库，其安全性和稳定性应该还是值得信赖的。如果是纯OC的项目，如果觉得CoreData学习成本高，不容易掌握，不是很稳定的话，推荐可以使用WCDB，但是项目中所有用到WCDB依赖的类实现文件都必须改成<code>.mm</code>的形式。但如果是Swift或者OC/Swift混编项目，WCDB目前对Swift还不是很友好，希望WCDB团队后续能对Swift进行支持吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WCDB（WeChat DataBase）是微信官方的移动端数据库组件，它基于SQLCipher，是一个关系型数据库，支持iOS, macO
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="Database" scheme="http://wuqiuhao.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>iOS自定义模态视图转场</title>
    <link href="http://wuqiuhao.github.io/2016/07/17/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE%E8%BD%AC%E5%9C%BA/"/>
    <id>http://wuqiuhao.github.io/2016/07/17/iOS自定义模态视图转场/</id>
    <published>2016-07-17T02:47:08.000Z</published>
    <updated>2016-07-19T01:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用淘宝App购物的时候，经常用到的一个操作就是加入购物车，好奇的朋友一定会发现，当我们在点击加入购物车按钮的时候出现了一个酷炫的动画。原本的视图出现了一定的折叠之后，仿佛嵌入了屏幕内部，随后弹出商品详细参数的页面。实际上，这是一种自定义的模态视图转场动画。下面我们一步一步分析实现类似的模态视图转场动画。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>首先我们创建<code>GoodsViewController</code>和<code>GoodsDetailViewController</code>分别作为商品页面和商品详细页面。创建<code>Shop.storyboard</code>,以及两个ViewController对应的视图如下。<br>  <img src="https://github.com/wuqiuhao/HCustomTransition/raw/master/resource/storyboard.png" alt="Shop.storyboard"></p>
</li>
<li><p>创建<code>CustomTransitioningDelegate</code>代理，用于dismiss方法回调。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol CustomTransitioningDelegate &#123;</div><div class="line">    // dismiss</div><div class="line">    func dismissPresentViewController()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>创建<code>CustomTransitioningAnimator</code>,作为我们所有转场动画的总代理。没错！转场导读需要花多少时间、转场该以怎样的动画进行都有它来控制。</li>
</ul>
<h2 id="present前的关键步奏"><a href="#present前的关键步奏" class="headerlink" title="present前的关键步奏"></a>present前的关键步奏</h2><p>“点击购物车”按钮的事件处理如下,在这里比较重要的是我们需要设置<code>modalPresentationStyle</code>为<code>Custom</code>类型，并把<code>transitioningDelegate</code>设置为<code>CustomTransitioningAnimator</code>类的实例<code>animator</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@IBAction func addGoodsToShopCart(sender: UIBarButtonItem) &#123;</div><div class="line">       let shopCartVC = UIStoryboard(name: &quot;Shop&quot;, bundle: nil).instantiateViewControllerWithIdentifier(&quot;GoodsDetailViewController&quot;) as! GoodsDetailViewController</div><div class="line">       animator = CustomTransitioningAnimator(presentViewController: shopCartVC)</div><div class="line">       shopCartVC.delegate = self</div><div class="line">       shopCartVC.modalPresentationStyle = UIModalPresentationStyle.Custom</div><div class="line">       shopCartVC.transitioningDelegate = animator</div><div class="line">       shopCartVC.panGesture = UIPanGestureRecognizer(target: animator, action: #selector(animator.handleGesture(_:)))</div><div class="line">       self.presentViewController(shopCartVC, animated: true, completion: nil)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="CustomTransitioningAnimator解析"><a href="#CustomTransitioningAnimator解析" class="headerlink" title="CustomTransitioningAnimator解析"></a>CustomTransitioningAnimator解析</h2><h3 id="UIViewControllerTransitioningDelegate协议实现"><a href="#UIViewControllerTransitioningDelegate协议实现" class="headerlink" title="UIViewControllerTransitioningDelegate协议实现"></a>UIViewControllerTransitioningDelegate协议实现</h3><p>由于我们上一步中提到的<code>transitioningDelegate</code>是<code>UIViewControllerTransitioningDelegate</code>类型的，所以我们的Animator（CustomTransitioningAnimator以下都简称Animator）首先需要实现<code>UIViewControllerTransitioningDelegate</code>协议。</p>
<ul>
<li>这四个方法用于设定present或dismiss的动画的代理对象，设置成self则由本类的方法实现，设置成nil则不处理。</li>
<li>如果是手势驱动的情况下，需要代理对象实现<code>UIViewControllerInteractiveTransitioning</code>协议，幸运的是系统为我们提供了<code>UIPercentDrivenInteractiveTransition</code>类，此类本生就实现了<code>UIViewControllerInteractiveTransitioning</code>协议，支持百分比变换，并在此基础上扩展<code>updateInteractiveTransition</code>、<code>finishInteractiveTransition</code>、<code>cancelInteractiveTransition</code>等方法，大大简化了手势驱动。</li>
<li>如果是非手势驱动我们的类需要实现<code>UIViewControllerAnimatedTransitioning</code>协议</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">extension CustomTransitioningAnimator: UIViewControllerTransitioningDelegate &#123;</div><div class="line">    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</div><div class="line">        isDismiss = false</div><div class="line">        return self</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</div><div class="line">        isDismiss = true</div><div class="line">        return self</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123;</div><div class="line">        isDismiss = true</div><div class="line">        return self.interacting ? self : nil</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123;</div><div class="line">        isDismiss = false</div><div class="line">        return nil</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非手势情况处理"><a href="#非手势情况处理" class="headerlink" title="非手势情况处理"></a>非手势情况处理</h3><p>在非手势的情况下，上面提到了我们需要实现<code>UIViewControllerAnimatedTransitioning</code>协议。<code>UIViewControllerAnimatedTransitioning</code>的方法介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval // 用于设置转场动画的时间</div><div class="line">public func animateTransition(transitionContext: UIViewControllerContextTransitioning) // 动画的具体实现细节</div><div class="line">optional public func animationEnded(transitionCompleted: Bool) // 动画完成时调用</div></pre></td></tr></table></figure>
<p>   非手势情况实现具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">// 非手势情况</div><div class="line">extension CustomTransitioningAnimator: UIViewControllerAnimatedTransitioning &#123;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     动画持续时间</div><div class="line">     </div><div class="line">     - parameter transitionContext:</div><div class="line">     </div><div class="line">     - returns:</div><div class="line">     */</div><div class="line">    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</div><div class="line">        return 0.25</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     动画执行效果</div><div class="line">     </div><div class="line">     - parameter transitionContext:</div><div class="line">     */</div><div class="line">    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</div><div class="line">        /**</div><div class="line">         *  如果是手势驱动的直接返回</div><div class="line">         */</div><div class="line">        guard !interacting else &#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        </div><div class="line">        /**</div><div class="line">         *  判断是否是dismiss的动画还是present的动画</div><div class="line">         */</div><div class="line">        if isDismiss! &#123;</div><div class="line">            let finalFrame = CGRect(x: 0, y: 0, width: UIScreen.mainScreen().bounds.width, height: UIScreen.mainScreen().bounds.height)</div><div class="line">            UIView.animateWithDuration(transitionDuration(transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseIn, animations: &#123;</div><div class="line">                fromViewController.view.frame = CGRect(x: 0, y: UIScreen.mainScreen().bounds.height, width: UIScreen.mainScreen().bounds.width, height: UIScreen.mainScreen().bounds.height)</div><div class="line">                var transform = CATransform3DIdentity</div><div class="line">                transform.m24 = -1/5000</div><div class="line">                transform = CATransform3DScale(transform, 0.95, 0.95, 1)</div><div class="line">                toViewController.view.layer.transform = transform</div><div class="line">                toViewController.view.alpha = 1</div><div class="line">            &#125;) &#123; (finished) in</div><div class="line">                if finished &#123;</div><div class="line">                    UIView.animateWithDuration(self.transitionDuration(transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseIn, animations: &#123;</div><div class="line">                        toViewController.view.layer.transform = CATransform3DIdentity</div><div class="line">                        toViewController.view.frame = finalFrame</div><div class="line">                    &#125;) &#123; (finished) in</div><div class="line">                       transitionContext.completeTransition(true)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            transitionContext.containerView()?.addSubview(toViewController.view)</div><div class="line">            let finalFrame = CGRect(x: 0, y: 0, width: UIScreen.mainScreen().bounds.width, height: UIScreen.mainScreen().bounds.height)</div><div class="line">            toViewController.view.frame = CGRectOffset(finalFrame, 0, UIScreen.mainScreen().bounds.height)</div><div class="line">            UIView.animateWithDuration(transitionDuration(transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseOut, animations: &#123;</div><div class="line">                var transform = CATransform3DIdentity</div><div class="line">                transform.m24 = -1/2000</div><div class="line">                fromViewController.view.alpha = 0.5</div><div class="line">                fromViewController.view.layer.transform = transform</div><div class="line">                toViewController.view.frame = finalFrame</div><div class="line">            &#125;) &#123; (finished) in</div><div class="line">                if finished &#123;</div><div class="line">                    UIView.animateWithDuration(self.transitionDuration(transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseOut, animations: &#123;</div><div class="line">                        var transform = CATransform3DIdentity</div><div class="line">                        transform = CATransform3DTranslate(transform, 0, -15, 0)</div><div class="line">                        transform = CATransform3DScale(transform, 0.8,0.9, 1)</div><div class="line">                        fromViewController.view.layer.transform = transform</div><div class="line">                    &#125;) &#123; (finished) in</div><div class="line">                        if finished &#123;</div><div class="line">                            transitionContext.completeTransition(true)</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="手势情况处理"><a href="#手势情况处理" class="headerlink" title="手势情况处理"></a>手势情况处理</h3><p>手势操作我们上面提到了，只要继承<code>UIPercentDrivenInteractiveTransition</code>这个类，就可以很方面的实现手势操作以及百分比动画。<code>UIPercentDrivenInteractiveTransition</code>有几个主要的方法介绍如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public func startInteractiveTransition(transitionContext: UIViewControllerContextTransitioning) // 实现自`UIViewControllerInteractiveTransitioning`协议，手势刚触发时调用</div><div class="line">public func updateInteractiveTransition(percentComplete: CGFloat) // 手势触发过程中不断调用，参数为百分比0~1。</div><div class="line">public func cancelInteractiveTransition() // 手势取消时调用</div><div class="line">public func finishInteractiveTransition() // 手势达到一定程度成功时调用</div></pre></td></tr></table></figure>
<p>手势操作百分比动画的具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line">class CustomTransitioningAnimator: UIPercentDrivenInteractiveTransition &#123;</div><div class="line">    </div><div class="line">    var isDismiss: Bool!</div><div class="line">    weak var presentViewController: UIViewController!</div><div class="line">    var transitionContext: UIViewControllerContextTransitioning!</div><div class="line">    // 是否处于交互视图切换过程</div><div class="line">    var interacting = false</div><div class="line">    // 是否手势完成</div><div class="line">    var shouleComplete = true</div><div class="line">    </div><div class="line">    init(presentViewController: UIViewController) &#123;</div><div class="line">        super.init()</div><div class="line">        self.presentViewController = presentViewController</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - 手势操作</div><div class="line">extension CustomTransitioningAnimator &#123;</div><div class="line">    /**</div><div class="line">     处理手势操作</div><div class="line">     </div><div class="line">     - parameter gestureRecognizer:</div><div class="line">     */</div><div class="line">    func handleGesture(gestureRecognizer: UIPanGestureRecognizer) &#123;</div><div class="line">        let translation = gestureRecognizer.translationInView(gestureRecognizer.view)</div><div class="line">        switch gestureRecognizer.state &#123;</div><div class="line">        case UIGestureRecognizerState.Began:</div><div class="line">            interacting = true</div><div class="line">            if presentViewController is GoodsDetailViewController &#123;</div><div class="line">                (presentViewController as! GoodsDetailViewController).delegate?.dismissPresentViewController()</div><div class="line">            &#125;</div><div class="line">        case .Changed:</div><div class="line">            var fraction = translation.y / 200.0</div><div class="line">            fraction = fmin(fmax(fraction, 0.0), 1.0)</div><div class="line">            shouleComplete = fraction &gt; 0.5</div><div class="line">            self.updateInteractiveTransition(fraction)</div><div class="line">        case .Ended, .Cancelled:</div><div class="line">            interacting = false</div><div class="line">            if !shouleComplete || gestureRecognizer.state == .Cancelled || gestureRecognizer.velocityInView(gestureRecognizer.view).y &lt; 0 &#123;</div><div class="line">                self.cancelInteractiveTransition()</div><div class="line">            &#125; else &#123;</div><div class="line">                self.finishInteractiveTransition()</div><div class="line">            &#125;</div><div class="line">        default:</div><div class="line">            break</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     开始手势拖拽</div><div class="line">     </div><div class="line">     - parameter transitionContext:</div><div class="line">     */</div><div class="line">    override func startInteractiveTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</div><div class="line">        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        self.transitionContext = transitionContext</div><div class="line">        UIView.animateWithDuration(transitionDuration(transitionContext)) &#123;</div><div class="line">            var transform = CATransform3DIdentity</div><div class="line">            transform = CATransform3DTranslate(transform, 0, 15, 0)</div><div class="line">            transform.m24 = -1/5000</div><div class="line">            transform = CATransform3DScale(transform, 0.85, 1 , 1)</div><div class="line">            toViewController.view.layer.transform = transform</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     手势拖动过程中不断更新</div><div class="line">     </div><div class="line">     - parameter percentComplete: 更新百分比0~1</div><div class="line">     */</div><div class="line">    override func updateInteractiveTransition(percentComplete: CGFloat) &#123;</div><div class="line">        guard let _ = transitionContext else &#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        var transform = CATransform3DIdentity</div><div class="line">        transform.m24 = -1/3500 + 1/3500 * percentComplete</div><div class="line">        transform = CATransform3DScale(transform, 0.85 + 0.15 * percentComplete, 0.9 + 0.1 * percentComplete , 1)</div><div class="line">        toViewController.view.layer.transform = transform</div><div class="line">        toViewController.view.alpha = 0.5 + 0.5 * percentComplete</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     完成手势dismiss</div><div class="line">     */</div><div class="line">    override func finishInteractiveTransition() &#123;</div><div class="line">        let finalFrame = CGRect(x: 0, y: 0, width: UIScreen.mainScreen().bounds.width, height: UIScreen.mainScreen().bounds.height)</div><div class="line">        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        UIView.animateWithDuration(2 * transitionDuration(transitionContext), animations: &#123;</div><div class="line">            fromViewController.view.frame = CGRect(x: 0, y: UIScreen.mainScreen().bounds.height, width: UIScreen.mainScreen().bounds.width, height: UIScreen.mainScreen().bounds.height)</div><div class="line">            toViewController.view.layer.transform = CATransform3DIdentity</div><div class="line">            toViewController.view.alpha = 1</div><div class="line">            toViewController.view.frame = finalFrame</div><div class="line">        &#125;) &#123; (finished) in</div><div class="line">            if finished &#123;</div><div class="line">                self.transitionContext.completeTransition(true)</div><div class="line">                self.transitionContext = nil</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     手势取消操作</div><div class="line">     */</div><div class="line">    override func cancelInteractiveTransition() &#123;</div><div class="line">        let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</div><div class="line">        let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</div><div class="line">        UIView.animateWithDuration(transitionDuration(transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseOut, animations: &#123; () -&gt; Void in</div><div class="line">            fromViewController.view.userInteractionEnabled = false</div><div class="line">            fromViewController.view.frame = CGRect(x: 0, y: 0, width: fromViewController.view.frame.width, height: fromViewController.view.frame.height)</div><div class="line">        &#125;) &#123; (finished) -&gt; Void in</div><div class="line">            if finished &#123;</div><div class="line">                UIView.animateWithDuration(self.transitionDuration(self.transitionContext), delay: 0, options: UIViewAnimationOptions.CurveEaseOut, animations: &#123;</div><div class="line">                    var transform = CATransform3DIdentity</div><div class="line">                    transform = CATransform3DTranslate(transform, 0, -15, 0)</div><div class="line">                    transform = CATransform3DScale(transform, 0.8,0.9, 1)</div><div class="line">                    toViewController.view.layer.transform = transform</div><div class="line">                    toViewController.view.alpha = 0.5</div><div class="line">                &#125;) &#123; (finished) in</div><div class="line">                    if finished &#123;</div><div class="line">                        fromViewController.view.userInteractionEnabled = true</div><div class="line">                        self.transitionContext.completeTransition(false)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h2><p>Github地址：<a href="https://github.com/wuqiuhao/HCustomTransition" target="_blank" rel="external">HCustomTransition</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用淘宝App购物的时候，经常用到的一个操作就是加入购物车，好奇的朋友一定会发现，当我们在点击加入购物车按钮的时候出现了一个酷炫的动画。原本的视图出现了一定的折叠之后，仿佛嵌入了屏幕内部，随后弹出商品详细参数的页面。实际上，这是一种自定义的模态视图转场动画。下面我们一
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="Custom Transition" scheme="http://wuqiuhao.github.io/tags/Custom-Transition/"/>
    
  </entry>
  
  <entry>
    <title>使用fastlane gym实现ipa自动打包脚本</title>
    <link href="http://wuqiuhao.github.io/2016/06/08/fastlane%20gym%E5%AE%9E%E7%8E%B0ipa%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC/"/>
    <id>http://wuqiuhao.github.io/2016/06/08/fastlane gym实现ipa自动打包脚本/</id>
    <published>2016-06-08T09:07:53.000Z</published>
    <updated>2016-06-08T09:24:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fastlane"><a href="#fastlane" class="headerlink" title="fastlane"></a>fastlane</h3><p>fastlane是一组工具套件，旨在实现iOS应用发布流程的自动化，并且提供一个运行良好的持续部署流程，只需要运行一个简单的命令就可以触发这个流程。</p>
<p>fastlane是一个ruby脚本集合，其中囊括了向苹果商店提交新应用或更新已有应用所需要的最常用任务。</p>
<ul>
<li>deliver用于上传应用的二进制代码，应用截屏和原数据到应用商店</li>
<li>snapshot可以自动化iOS应用在每个设备上的本地化截屏过程</li>
<li>frameit用于在应用截屏外添加设备框架</li>
<li>PEM可以自动化地生成和更新应用推送通知描述文件</li>
<li>sigh可以生成并下载开发者的应用商店配置文件</li>
</ul>
<h3 id="使用fastlane-gym打包"><a href="#使用fastlane-gym打包" class="headerlink" title="使用fastlane gym打包"></a>使用fastlane gym打包</h3><h4 id="安装gym"><a href="#安装gym" class="headerlink" title="安装gym"></a>安装gym</h4><p>首先需要安装ruby环境，然后在命令行中输入：</p>
<p><code>sudo gem install gym</code></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>*.workspace文件</li>
</ul>
<p>使用<code>CocoaPods</code>管理的工程在执行完<code>pod install</code>之后生成的workspace文件</p>
<ul>
<li>scheme</li>
</ul>
<p>显示在Xcode的左上角，run图标的右边，设备选择的左边</p>
<ul>
<li>configuration</li>
</ul>
<p>在Xcode中选项目，Info tab下会列出所有的configuration，一般有Debug和Release两种</p>
<ul>
<li>provisioning profile</li>
</ul>
<p>在Xcode中选target，在Build Settings tab下搜索Provisioning Profile，默认应该是Automatic，点击看到下拉列表中的就是所有可用的名称</p>
<h4 id="脚本执行步骤"><a href="#脚本执行步骤" class="headerlink" title="脚本执行步骤"></a>脚本执行步骤</h4><ol>
<li><p>清理项目</p>
</li>
<li><p>生成archive</p>
</li>
<li><p>导出ipa</p>
</li>
<li><p>上传到fir</p>
</li>
</ol>
<h4 id="上脚本"><a href="#上脚本" class="headerlink" title="上脚本"></a>上脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#计时</div><div class="line">SECONDS=0</div><div class="line">project_path=$(pwd)</div><div class="line">now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)</div><div class="line">current_user=$(logname)</div><div class="line">scheme=&quot;your scheme name&quot;</div><div class="line"></div><div class="line">configuration=&quot;Release&quot;</div><div class="line">#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</div><div class="line">export_method=&apos;ad-hoc&apos;</div><div class="line"></div><div class="line">workspace_path=&quot;$project_path/$scheme.xcworkspace&quot;</div><div class="line"></div><div class="line">output_path=&quot;/Users/$current_user/Desktop&quot;</div><div class="line"></div><div class="line">archive_path=&quot;$output_path/$scheme$&#123;now&#125;.xcarchive&quot;</div><div class="line"></div><div class="line">ipa_path=&quot;$output_path/$scheme$&#123;now&#125;.ipa&quot;</div><div class="line"></div><div class="line">ipa_name=&quot;$scheme$&#123;now&#125;.ipa&quot;</div><div class="line"></div><div class="line">commit_msg=&quot;$1&quot;</div><div class="line"></div><div class="line">fir_token=&quot;your fir token&quot;</div><div class="line"></div><div class="line">#输出设定的变量值</div><div class="line">echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;</div><div class="line">echo &quot;===archive path: $&#123;archive_path&#125;===&quot;</div><div class="line">echo &quot;===ipa path: $&#123;ipa_path&#125;===&quot;</div><div class="line">echo &quot;===export method: $&#123;export_method&#125;===&quot;</div><div class="line">echo &quot;===commit msg: $1===&quot;</div><div class="line"></div><div class="line">#先清空前一次build</div><div class="line">gym --workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; -clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;output_path&#125; --output_name $&#123;ipa_name&#125;</div><div class="line"></div><div class="line">#上传到fir</div><div class="line">#fir publish $&#123;ipa_path&#125; -T &quot;$&#123;fir_token&#125;&quot; -c &quot;$&#123;commit_msg&#125;&quot;</div><div class="line"></div><div class="line">#输出总用时</div><div class="line">echo &quot;===Finished. Total time: $&#123;SECONDS&#125;s===&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fastlane&quot;&gt;&lt;a href=&quot;#fastlane&quot; class=&quot;headerlink&quot; title=&quot;fastlane&quot;&gt;&lt;/a&gt;fastlane&lt;/h3&gt;&lt;p&gt;fastlane是一组工具套件，旨在实现iOS应用发布流程的自动化，并且提供一个运行良好的持
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="自动打包" scheme="http://wuqiuhao.github.io/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的生成器和序列</title>
    <link href="http://wuqiuhao.github.io/2016/06/02/Swift%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E5%BA%8F%E5%88%97/"/>
    <id>http://wuqiuhao.github.io/2016/06/02/Swift中的生成器和序列/</id>
    <published>2016-06-02T14:00:05.000Z</published>
    <updated>2016-06-02T15:01:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>生成器(Generators)与序列(Sequences)构成了Swift式循环。</p>
<h2 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h2><p>提到数组我们就会想到遍历，一般的遍历可能都是从头到尾进行的。但是如果你有特殊的需求呢。你可能不想呆板的进行遍历。这时候Generators就可以派上用场了。<br>Generators的存在是进行特殊癖好的数组遍历，其筛选出符合该癖好的下标索引到数组没有元素为止。<br>任意一个generator都需要遵从如下协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol GeneratorType &#123; </div><div class="line">    associatedtype Element</div><div class="line">    func next() -&gt; Element?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上述协议，该协议需要元素类型以及一个next()函数。</p>
<p>举个倒序索引的generator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class CountdownGenerator: GeneratorType &#123;</div><div class="line">    typealias Element = Int</div><div class="line">    var element: Element</div><div class="line"></div><div class="line">    init&lt;T&gt;(array: [T]) &#123;</div><div class="line">        self.element = array.count - 1</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func next() -&gt; Element? &#123;</div><div class="line">        return self.element &lt; 0 ? nil : element--</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xs = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div><div class="line">let generator = CountdownGenerator(array: xs)</div><div class="line">while let i = generator.next() &#123;</div><div class="line">    println(&quot;Element \(i) of the array is \(xs[i])&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>Element 2 of the array is C</p>
<p>Element 1 of the array is B</p>
<p>Element 0 of the array is A</p>
<p>优点：</p>
<p>尽管这个小例子看起来有点小题大做，可生成器却封装了数组序列值的计算。如果你想要用另一种方式排序序列值，我们只需要更新生成器，而不必再修改这里的代码。</p>
<h2 id="序列-Sequences"><a href="#序列-Sequences" class="headerlink" title="序列(Sequences)"></a>序列(Sequences)</h2><p>Generators在循环过程中每个元素提供的服务是一次性的。所以我们想做倒回操作的话需要生成一个新的generator。若不想这样则需要用上sequence，其遵从另外一个协议SequenceType：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SequenceType &#123;</div><div class="line">    associatedtype Generator: GeneratorType </div><div class="line">    func generate() -&gt; Generator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过协议我们知道每个sequence都与一个generator类型已经一个generator构造器绑定在一起。我们可以使用这个遍历sequence。<br>举个栗子，我们可以使用CountdownGenerator来定义一个sequence从而生成一个倒序的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct ReverseSequence&lt;T&gt;: SequenceType &#123;</div><div class="line">    var array: [T]</div><div class="line">    init(array: [T]) &#123;</div><div class="line">        self.array = array</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    typealias Generator = CountdownGenerator</div><div class="line"></div><div class="line">    func generate() -&gt; Generator &#123;</div><div class="line">        return CountdownGenerator(array: array)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let xs = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div><div class="line">let reverseSequence = ReverseSequence(array: xs)</div><div class="line">let reverseGenerator = reverseSequence.generate()</div><div class="line">while let i = reverseGenerator.next() &#123;</div><div class="line">    println(&quot;Index \(i) is \(xs[i])&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>Index 2 is C</p>
<p>Index 1 is B</p>
<p>Index 0 is A</p>
<p>Swift在处理序列时有一个特别的语法。不同于创建一个序列的关联生成器，你可以编写一个for-in循环。比如，我们也可以将上面的代码段写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i in ReverseSequence(array: xs) &#123;</div><div class="line">	print(&quot;Index \(i) is \(xs[i ])&quot;)&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>Index 2 is C</p>
<p>Index 1 is B</p>
<p>Index 0 is A</p>
<p>实际上，Swift做的只是使用generate方法生成了一个生成器，然后重复地调用其next函数直到返回nil。</p>
<p>优点：</p>
<p>对比之前仅仅使用生成器的例子，同一个序列可以被第二次遍历–为此我们只需要调用generate来生成一个新的生成器就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;生成器(Generators)与序列(Sequences)构成了Swift式循环。&lt;/p&gt;
&lt;h2 id=&quot;生成器-Generators&quot;&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="GeneratorType" scheme="http://wuqiuhao.github.io/tags/GeneratorType/"/>
    
      <category term="SequenceType" scheme="http://wuqiuhao.github.io/tags/SequenceType/"/>
    
  </entry>
  
  <entry>
    <title>iOS视频、音频播放</title>
    <link href="http://wuqiuhao.github.io/2016/04/05/iOS%E8%A7%86%E9%A2%91%E3%80%81%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://wuqiuhao.github.io/2016/04/05/iOS视频、音频播放/</id>
    <published>2016-04-05T05:04:53.000Z</published>
    <updated>2016-04-16T08:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、AVPlayerViewController"><a href="#一、AVPlayerViewController" class="headerlink" title="一、AVPlayerViewController"></a>一、AVPlayerViewController</h2><p>iOS9之前，我们经常使用<code>MPMoviePlayerController</code>实现视频、音频文件的播放。iOS9之后，MPMoviePlayerController被苹果弃用，苹果推荐使用<code>AVPlayerViewController</code>，AVPlayerViewController的功能比MPMoviePlayerController更为强大。单独使用AVPlayer我们就可以实现视频和音频两种文件的播放。由于其基于AVFoundation和AVKit，所以在开始使用之前我们需要先导入<code>AVFoundation</code>框架。具体实现如下:</p>
<h3 id="加载本地视频资源"><a href="#加载本地视频资源" class="headerlink" title="加载本地视频资源"></a>加载本地视频资源</h3><p>如果需要加载本地音频文件只需修改资源的后缀为音频对应的后缀名，如MP3。</p>
<p><code>let filePath = NSBundle.mainBundle().pathForResource(&quot;赵传 - 每次都想呼喊你的名字&quot;, ofType: &quot;mp3&quot;)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import AVKit</div><div class="line">import AVFoundation</div><div class="line"></div><div class="line">lazy var playerController: AVPlayerViewController = &#123;</div><div class="line">        let filePath = NSBundle.mainBundle().pathForResource(&quot;音乐喷泉&quot;, ofType: &quot;mp4&quot;)</div><div class="line">        let sourceMovieURL = NSURL(fileURLWithPath: filePath!)</div><div class="line">        let movieAsset = AVURLAsset(URL: sourceMovieURL)</div><div class="line">        let playItem = AVPlayerItem(asset: movieAsset)</div><div class="line">        let player = AVPlayer(playerItem: playItem)</div><div class="line">        let playerController = AVPlayerViewController()</div><div class="line">        playerController.player = player</div><div class="line">        playerController.view.frame = self.view.frame</div><div class="line">        self.addChildViewController(playerController)</div><div class="line">        playerController.videoGravity = AVLayerVideoGravityResizeAspectFill</div><div class="line">        return playerController</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        self.view.addSubview(playerController.view)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>AVFoundation支持三种视频填充模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AVLayerVideoGravityResizeAspect		保留长宽比，未填充部分会有黑边</div><div class="line">AVLayerVideoGravityResizeAspectFill	保留长宽比，填充所有的区域</div><div class="line">AVLayerVideoGravityResize		拉伸填满所有的空间</div></pre></td></tr></table></figure>
<h3 id="加载网络视频"><a href="#加载网络视频" class="headerlink" title="加载网络视频"></a>加载网络视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lazy var playerController: AVPlayerViewController = &#123;</div><div class="line">        let player = AVPlayer(URL: NSURL(string:</div><div class="line">            &quot;http://www.ebookfrenzy.com/ios_book/movie/movie.mov&quot;)!)</div><div class="line">        let playerController = AVPlayerViewController()</div><div class="line">        playerController.player = player</div><div class="line">        playerController.view.frame = self.view.frame</div><div class="line">        self.addChildViewController(playerController)</div><div class="line">        playerController.videoGravity = AVLayerVideoGravityResizeAspectFill</div><div class="line">        return playerController</div><div class="line">    &#125;()</div></pre></td></tr></table></figure>
<h2 id="二、AVAudioPlayer"><a href="#二、AVAudioPlayer" class="headerlink" title="二、AVAudioPlayer"></a>二、AVAudioPlayer</h2><p>AVAudioPlayer封装了播放单个音频的能力。可以通过NSURL或NSData来初始化，AVAudioPlayer不具备流媒体播放能力，但是我们能够通过网络请求后获取的NSData间接实现播放网络资源。首先，我们同样需要导入AVFoundation框架，具体实现如下：</p>
<h3 id="加载本地音频"><a href="#加载本地音频" class="headerlink" title="加载本地音频"></a>加载本地音频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import AVFoundation</div><div class="line"></div><div class="line">class AudioPlayerViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    lazy var audioPlayer: AVAudioPlayer? = &#123;</div><div class="line">        let filePath = NSBundle.mainBundle().pathForResource(&quot;赵传 - 每次都想呼喊你的名字&quot;, ofType: &quot;mp3&quot;)</div><div class="line">        let sourceAudioURL = NSURL(fileURLWithPath: filePath!)</div><div class="line">        let audioPlayer: AVAudioPlayer!</div><div class="line">        do &#123;</div><div class="line">            audioPlayer = try AVAudioPlayer(contentsOfURL: sourceAudioURL)</div><div class="line">            audioPlayer.delegate = self</div><div class="line">            return audioPlayer</div><div class="line">        &#125; catch &#123;</div><div class="line">            // TODO:couldn&apos;t load file :(</div><div class="line">        &#125;</div><div class="line">        return nil</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        audioPlayer?.play()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension AudioPlayerViewController: AVAudioPlayerDelegate &#123;</div><div class="line">    // 音频播放完毕时</div><div class="line">    func audioPlayerDidFinishPlaying(player: AVAudioPlayer, successfully flag: Bool) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 解码错误</div><div class="line">    func audioPlayerDecodeErrorDidOccur(player: AVAudioPlayer, error: NSError?) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 当音频播放过程中被中断时</div><div class="line">    func audioPlayerBeginInterruption(player: AVAudioPlayer) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 当中断结束时</div><div class="line">    func audioPlayerEndInterruption(player: AVAudioPlayer, withOptions flags: Int) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="加载网络音频"><a href="#加载网络音频" class="headerlink" title="加载网络音频"></a>加载网络音频</h3><blockquote>
<ol>
<li>加载网络音频文件，我们的策略是通过网络请求获取音频流的NSData数据，然后使用AVPlayer的初始化方法   获取player实例，进行播放;</li>
<li>对于iOS7以上的系统（含iOS7）,在确定文件格式的情况下可以使用-initWithData:fileTypeHint:error:和-initWithContentsOfURL:fileTypeHint:error:生成实例，或者把NSData保存为对应后缀名的文件后使用-initWithContentsOfURL:error:后再生成实例;</li>
<li>对于iOS7以下的系统，在确定文件格式的情况下，最为安全的方法是把NSData保存为对应后缀名的文件后使用-initWithContentsOfURL:error:生成实例。</li>
</ol>
</blockquote>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>关于加载网络音频的更多注意事项，可以参见“码农人生”的技术博客:<br><a href="http://msching.github.io/blog/2014/05/04/secret-of-avaudioplayer/" target="_blank" rel="external">AVAudioPlayer的1937337955错误研究</a></p>
<h2 id="三、AVPlayer"><a href="#三、AVPlayer" class="headerlink" title="三、AVPlayer"></a>三、AVPlayer</h2><p><code>AVPlayer</code>支持本地和网络流媒体播放，AVPlayerViewController实际上是AVPlayer的封装，如果我们想要自定义一款流媒体视频或音频播放器，我们可以简单的使用AVPlayer实现。AVPlayer的具体实现如下：</p>
<h3 id="初始化AVPlayer"><a href="#初始化AVPlayer" class="headerlink" title="初始化AVPlayer"></a>初始化AVPlayer</h3><p>此处的url可以上本地媒体资源url也可以是网络资源url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let playerItem = AVPlayerItem(URL: NSURL(string: &quot;url&quot;)!)</div><div class="line">let player = AVPlayer(playerItem: playerItem)</div></pre></td></tr></table></figure>
<h3 id="添加属性监听"><a href="#添加属性监听" class="headerlink" title="添加属性监听"></a>添加属性监听</h3><p>此处利用KVO监听player的currentItem的status和loadTimeRanges两个属性。status是表示player状态的一个枚举，只有当status状态为ReadyToPlay时，我们才能对资源进行播放，并获取音频时长等信息。通过对loadTimeRanges属性的实时监听，获取资源的缓冲进度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum AVPlayerStatus : Int &#123;</div><div class="line">    </div><div class="line">    case Unknown</div><div class="line">    case ReadyToPlay</div><div class="line">    case Failed</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 添加监听</div><div class="line">func addObserverForPlayItem() &#123;</div><div class="line">    player.currentItem?.addObserver(self, forKeyPath: &quot;status&quot;, options: NSKeyValueObservingOptions.New, context: nil)</div><div class="line">    player.currentItem?.addObserver(self, forKeyPath: &quot;loadedTimeRanges&quot;, options: NSKeyValueObservingOptions.New, context: nil)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 移除监听</div><div class="line">func removeObserverForPlayItem() &#123;</div><div class="line">    player.currentItem?.removeObserver(self, forKeyPath: &quot;status&quot;)</div><div class="line">    player.currentItem?.removeObserver(self, forKeyPath: &quot;loadedTimeRanges&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</div><div class="line">    if keyPath == &quot;status&quot; &#123;</div><div class="line">        let status = change![&quot;new&quot;] as! Int</div><div class="line">        if status == AVPlayerStatus.ReadyToPlay.rawValue &#123;</div><div class="line">            // 例如获取音频时长，刷新UI界面</div><div class="line">        &#125;</div><div class="line">    &#125; else if keyPath == &quot;loadedTimeRanges&quot; &#123;</div><div class="line">        let array = player.currentItem?.loadedTimeRanges</div><div class="line">        let timeRanges = array?.first?.CMTimeRangeValue</div><div class="line">        let startSeconds = CMTimeGetSeconds(timeRanges!.start)</div><div class="line">        let durationSeconds = CMTimeGetSeconds(timeRanges!.duration)</div><div class="line">        let bufferTime = startSeconds + durationSeconds</div><div class="line">        // 获取bufferTime刷新界面缓冲进度条</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他相关属性、方法介绍"><a href="#其他相关属性、方法介绍" class="headerlink" title="其他相关属性、方法介绍"></a>其他相关属性、方法介绍</h3><p>播放：<code>player.play()</code></p>
<p>暂停：<code>player.pause（）</code></p>
<p>获取当前播放时间：timeScale指的是1秒需要有几个帧构成（fps），所以要得到秒数，需要用如下方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let currentTime = Double(player.currentTime().value) / Double(player.currentTime().timescale)</div></pre></td></tr></table></figure>
<p>获取总时长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let duration = Double(player.currentItem!.duration.value) / Double(player.currentItem!.duration.timescale)</div></pre></td></tr></table></figure>
<p>拖动进度条：<code>player.seekToTime(time: cmTime)</code></p>
<p>这个方法可以指定播放到哪一个时刻，参数是一个CMTime类型的数据，CMTime是一种用于表征媒体资源时间的专用类。我们可以通过CMTime构造方法创建CMTime实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">timeScale = player.currentItem.duration.timeScale</div><div class="line">let cmTime = CMTime(seconds: seconds, preferredTimescale: timeScale)</div></pre></td></tr></table></figure>
<h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p><a href="http://msching.github.io/blog/2014/07/07/audio-in-ios/" target="_blank" rel="external">码农人生 iOS音频播放系列博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、AVPlayerViewController&quot;&gt;&lt;a href=&quot;#一、AVPlayerViewController&quot; class=&quot;headerlink&quot; title=&quot;一、AVPlayerViewController&quot;&gt;&lt;/a&gt;一、AVPlayerView
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="AVPlayerViewController" scheme="http://wuqiuhao.github.io/tags/AVPlayerViewController/"/>
    
  </entry>
  
  <entry>
    <title>UILabel垂直方向布局调整——实现居上居下效果</title>
    <link href="http://wuqiuhao.github.io/2016/03/30/UILabel%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%8A%E5%B1%85%E4%B8%8B%E6%95%88%E6%9E%9C/"/>
    <id>http://wuqiuhao.github.io/2016/03/30/UILabel垂直方向布局调整——实现居上居下效果/</id>
    <published>2016-03-30T02:49:34.000Z</published>
    <updated>2016-04-16T07:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS UIKit框架默认只能通过UILable的textAlignment属性调整其水平方向上的布局，设置文字水平居左、居中和居右。不能对文字垂直方向上的布局做出直接调整，但是我们通过重写UILabel的textRectForBounds和drawTextInRect方法，能够很便捷的调整UILable的内容布局，实现居上、垂直居中和居下的效果。具体实现如下：</p>
<h3 id="创建VerticalAlignment枚举"><a href="#创建VerticalAlignment枚举" class="headerlink" title="创建VerticalAlignment枚举"></a>创建VerticalAlignment枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum VerticalAlignment &#123;</div><div class="line">	case Top</div><div class="line">	case Middle</div><div class="line">	case Bottom</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写UILabel"><a href="#重写UILabel" class="headerlink" title="重写UILabel"></a>重写UILabel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class HLable: UILabel &#123;</div><div class="line">    </div><div class="line">    override init(frame: CGRect) &#123;</div><div class="line">        self.verticalAlignment = .Middle</div><div class="line">        super.init(frame: frame)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    required init?(coder aDecoder: NSCoder) &#123;</div><div class="line">        self.verticalAlignment = .Middle</div><div class="line">        super.init(coder: aDecoder)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var verticalAlignment: VerticalAlignment &#123;</div><div class="line">        didSet &#123;</div><div class="line">            self.setNeedsDisplay()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func textRectForBounds(bounds: CGRect, limitedToNumberOfLines numberOfLines: Int) -&gt; CGRect &#123;</div><div class="line">        var textRect = super.textRectForBounds(bounds, limitedToNumberOfLines: numberOfLines)</div><div class="line">        switch self.verticalAlignment &#123;</div><div class="line">        case .Top:</div><div class="line">            textRect.origin.y = bounds.origin.y</div><div class="line">        case .Bottom:</div><div class="line">            textRect.origin.y = bounds.origin.y + bounds.size.height - textRect.size.height</div><div class="line">        case .Middle:</div><div class="line">            textRect.origin.y = bounds.origin.y + (bounds.size.height - textRect.size.height) / 2.0</div><div class="line">        &#125;</div><div class="line">        return textRect</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    override func drawTextInRect(rect: CGRect) &#123;</div><div class="line">        let actualRect = self.textRectForBounds(rect, limitedToNumberOfLines: numberOfLines)</div><div class="line">        super.drawTextInRect(actualRect)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let label = HLabel()</div><div class="line">label.verticalAlignment = .Top</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS UIKit框架默认只能通过UILable的textAlignment属性调整其水平方向上的布局，设置文字水平居左、居中和居右。不能对文字垂直方向上的布局做出直接调整，但是我们通过重写UILabel的textRectForBounds和drawTextInRect方法
    
    </summary>
    
      <category term="iOS" scheme="http://wuqiuhao.github.io/categories/iOS/"/>
    
    
      <category term="UILabel" scheme="http://wuqiuhao.github.io/tags/UILabel/"/>
    
  </entry>
  
</feed>
